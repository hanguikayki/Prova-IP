# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1skr386XDd8s-LzM5KSH2T7dGA_to-xfe
"""

#Aluno: Kayki Hiroyuki Lira Matos Hangui
#Questão 4, lógica base de um jogo inspirado no Tetris

import random
import time

#Por aqui defini a medida do tamanho do tabuleiro
largura = 10
comprimento= 18

#Peças do jogo (representadas por matrizes) (1 = bloco, 0 = vazio), criei elas usando parte do meu sobrenome (Hangui)
pecas = {
    'H': [[1, 1, 1, 1]],
    'A': [[1, 1],
         [1, 1]],
    'N': [[0, 1, 0],
          [1, 1, 1]],
    'G': [[0, 1, 1],
          [1, 1, 0]],
    'I': [[1, 1, 0],
          [0, 1, 1]],
}

#Aqui pedi  para criar um tabuleiro iniciado com 0, usando list comprehension, cada linha representa uma linha do tabuleiro, cada coluna uma posição vazia ou ocupada
tabuleiro = [[0 for _ in range(largura)] for _ in range(comprimento)]

#Mostra o tabuleiro no terminal, aqui eu utilizei for para iterar sobre cada linha, join() + expressão codicional (if celula) pra mostrar "[]" se a celula tiver ocupada
#(|) simula as bordas do jogo (visualmente)
def imprimir_tabuleiro():
    print("\n" + "-" * (largura * 2 + 2))
    for linha in tabuleiro:
        print("|" + "".join("[]" if celula else "  " for celula in linha) + "|")
    print("-" * (largura * 2 + 2))

#Aqui retorna uma peça aleatória do dicionário, random.choice() e list(pecas.values()) para escolher uma das matrizes das peças
def gerar_peca():
    return random.choice(list(pecas.values()))

#Olhar direitinho se a peça cabe no lugar atual
def cabe_peca(peca, lin, col):
    for i in range(len(peca)):
        for j in range(len(peca[i])):
            if peca[i][j]:
                l = lin + i
                c = col + j
                if l >= comprimento or c < 0 or c >= largura or tabuleiro[l][c]:
                    return False
    return True

#Fixa a peça no tabuleiro (transforma os 1's da peça em 1's no tabuleiro)
def fixar_peca(peca, lin, col):
    for i in range(len(peca)):
        for j in range(len(peca[i])):
            if peca[i][j]:
                tabuleiro[lin + i][col + j] = 1

#Loop do jogo (simula 5 peças despencando/caindo, uma de cada vez), lin começa em 0 (topo do tabuleiro), col centraliza a peça horizontalmente usando calculo de deslocamento com
#base na largura da peça (len(peca[0])).
for _ in range(5):
    peca = gerar_peca()
    lin = 0
    col = largura // 2 - len(peca[0]) // 2  # Centraliza a peça

#Move a peça pra baixo o máximo que der, usei time.sleep(0.1) pra simular o tempo de queda da peça, atualiza o tabuleiro em tempo real com imprimir_tabuleiro().
    while cabe_peca(peca, lin + 1, col):
        lin += 1
        imprimir_tabuleiro()
        time.sleep(0.1)  #Simula tempo de queda

#Quando não pode mais descer, fixa a peça no tabuleiro
    fixar_peca(peca, lin, col)
    imprimir_tabuleiro()
    time.sleep(0.4)